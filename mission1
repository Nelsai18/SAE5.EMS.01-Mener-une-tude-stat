```{r}
library(readxl)
library(dplyr)
library(janitor)
library(tidyr)
library(ggplot2)
```


# ------------------------------------------------------------
##---------------------- 1.Évolution du parc automobile électrique jusqu’à 2040. ----------------------##
# ------------------------------------------------------------


# Importation + nettoyage des données
```{r}
data <- read_excel("2if5.xls", skip = 3)  
data <- clean_names(data)

data <- fill(data, energie, .direction = "down") %>%
  filter(!grepl("Total|Toutes|non|dét", energie, ignore.case = TRUE),
         !co2_g_km %in% c("Total", "Non dét.")) %>%
  mutate(across(starts_with("x"), as.numeric))

# Format long
data_long <- data %>%
  pivot_longer(
    cols = starts_with("x"),
    names_to = "annee",
    values_to = "nombre"
  ) %>%
  mutate(annee = as.numeric(gsub("x", "", annee)))
```


# 1. Préparer les catégories d’énergie 
```{r}
data_grouped <- data_long %>%
  mutate(
    categorie = case_when(
      grepl("^Electricité$", energie, ignore.case = TRUE) ~ "Électrique",
      grepl("Electricité \\+ Essence|Electricité \\+ Gazole", energie, ignore.case = TRUE) ~ "Hybride rechargeable",
      grepl("^Essence$", energie, ignore.case = TRUE) ~ "Essence",
      grepl("^Gazole$", energie, ignore.case = TRUE) ~ "Gazole",
      grepl("GPL|Gaz Naturel", energie, ignore.case = TRUE) ~ "GPL / Gaz naturel",
      TRUE ~ "Autres"
    )
  ) %>%
  filter(categorie != "Autres") %>%
  group_by(annee, categorie) %>%
  summarise(nombre_annuel = sum(nombre, na.rm = TRUE), .groups = "drop")
```


# 2. Graphique 1 : Électrique + Hybride rechargeable
```{r}
data_eh <- data_grouped %>%
  filter(categorie %in% c("Électrique", "Hybride rechargeable"))

ggplot(data_eh, aes(x = annee, y = nombre_annuel, color = categorie)) +
  geom_line(size = 1.4) +
  geom_point(size = 2.5) +
  scale_color_manual(
    values = c(
      "Électrique" = "#0072B2",
      "Hybride rechargeable" = "#D55E00"
    ),
    name = "Type d'énergie"
  ) +
  labs(
    title = "Évolution des immatriculations : Électrique vs Hybride rechargeable",
    x = "Année",
    y = "Nombre de véhicules immatriculés"
  ) +
  theme_minimal(base_size = 15) +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold", size = 18),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```


# 3. Graphique 2 : Essence, Gazole, GPL/Gaz naturel
```{r}
data_therm <- data_grouped %>%
  filter(categorie %in% c("Essence", "Gazole", "GPL / Gaz naturel"))

ggplot(data_therm, aes(x = annee, y = nombre_annuel, color = categorie)) +
  geom_line(size = 1.4) +
  geom_point(size = 2.5) +
  scale_color_manual(
    values = c(
      "Essence" = "#009E73",
      "Gazole" = "#CC79A7",
      "GPL / Gaz naturel" = "#F0E442"
    ),
    name = "Motorisation"
  ) +
  labs(
    title = "Évolution des immatriculations : Essence, Gazole, GPL/Gaz naturel",
    x = "Année",
    y = "Nombre de véhicules immatriculés"
  ) +
  theme_minimal(base_size = 15) +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold", size = 18),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```


# Prévisions Jusqu'à 2040

# Séparer les jeux de données Électrique et Hybride
```{r}
# Données électriques
data_elec_sum <- data_grouped %>%
  filter(categorie == "Électrique") %>%
  arrange(annee)

# Données hybrides rechargeables
data_hybride_sum <- data_grouped %>%
  filter(categorie == "Hybride rechargeable") %>%
  arrange(annee)
```

# Fonction propre pour faire une prévision
```{r}
plot_prevision <- function(data_sum, titre) {
  
  # 1. Observations jusqu'en 2019
  data_obs <- data_sum %>% filter(annee <= 2019)
  
  # 2. Modèle polynomial degré 2
  modele_poly <- lm(nombre_annuel ~ poly(annee, 2), data = data_obs)
  
  # 3. Années futures
  future_years <- data.frame(annee = 2020:2040)
  future_years$projection <- predict(modele_poly, newdata = future_years)
  
  # 4. Graphique final
  ggplot() +
    geom_line(data = data_obs,
              aes(x = annee, y = nombre_annuel,
                  color = "Observé", linetype = "Observé"),
              size = 1.2) +
    
    geom_line(data = future_years,
              aes(x = annee, y = projection,
                  color = "Projection", linetype = "Projection"),
              size = 1.2) +
    
    scale_y_continuous(labels = scales::comma)+

    
    scale_color_manual(
      name = "Type",
      values = c("Observé" = "blue", "Projection" = "red")
    ) +
    scale_linetype_manual(
      name = "Type",
      values = c("Observé" = "solid", "Projection" = "dashed")
    ) +
    
    labs(
      title = titre,
      subtitle = "Prévision basée sur une régression polynomiale (degré 2)\nProjection à partir de 2019",
      x = "Année",
      y = "Immatriculations"
    ) +
    
    theme_minimal(base_size = 14) +
    theme(
      plot.title = element_text(face = "bold", size = 18),
      legend.position = "top",
      legend.title = element_text(face = "bold")
    )
}
```

# Générer les deux graphiques
```{r}
# Prévision pour les voitures électriques
plot_prevision(data_elec_sum, "Prévision pour les voitures électriques")

# Prévision pour les hybrides rechargeables
plot_prevision(data_hybride_sum, "Prévision pour les Hybrides rechargeables")
```




##---------------------- 2.Identification et classification des inégalités locales des voitures électriques. ----------------------##
```{r}
# ================================================
# Carte des inégalités locales VE – 2.I.R.5
# ================================================

library(readxl)
library(dplyr)
library(janitor)
library(tidyr)
library(sf)
library(tmap)

# 1. Importation de la feuille 2019
data2 <- read_excel("2ir5.xls", sheet = "2019", skip = 3)

# 2. Renommer les colonnes
colnames(data2)[1:15] <- c(
  "region",           
  "departement",      
  "essence_6cv",      
  "essence_6_7cv",    
  "essence_8cv_plus", 
  "elec_essence_6cv", 
  "elec_essence_6cv_plus",
  "gazole_6cv",       
  "gazole_6cv_plus",  
  "essence_gpl_6cv",  
  "essence_gpl_6cv_plus", 
  "electricite",      
  "gazole_electricite",
  "autres",           
  "total"             
)

# 3. Remplir les valeurs manquantes de 'region'
data2 <- tidyr::fill(data2, region, .direction = "down")

# 4. Supprimer les lignes totaux / non déterminées
data2 <- data2 %>%
  filter(!grepl("Total|Toutes|non|dét", departement, ignore.case = TRUE))

# 5. Pivot long : énergie et puissance en colonne unique
data_long <- data2 %>%
  pivot_longer(
    cols = c(essence_6cv:electricite),
    names_to = "energie",
    values_to = "nombre"
  ) %>%
  mutate(nombre = as.numeric(nombre))

# 6. Filtrer uniquement véhicules électriques
data_elec <- data_long %>%
  filter(grepl("electricite", energie, ignore.case = TRUE),
         !is.na(nombre))

# 7. Regrouper par département
ve_by_dept <- data_elec %>%
  group_by(departement) %>%
  summarise(nb_ve = sum(nombre), .groups = "drop")

# 8. Lire le shapefile des départements
fr_dept <- st_read("Departements.shp")

# 9. Joindre les données VE avec le shapefile
ve_map <- fr_dept %>%
  left_join(ve_by_dept, by = c("DDEP_L_LIB" = "departement"))

# 10. Supprimer les géométries vides
ve_map <- ve_map[!st_is_empty(ve_map), ]

ve_map <- st_make_valid(ve_map) # transforme les polygones invalides en géométries valides.

# 11. Limiter la carte à la France métropolitaine
ve_map <- st_crop(ve_map, xmin = -5.5, xmax = 10, ymin = 41, ymax = 51)

# 12. Créer une catégorie faible/moyen/élevé pour les VE
ve_map <- ve_map %>%
  mutate(categorie = cut(nb_ve,
                         breaks = quantile(nb_ve, probs = c(0, 0.33, 0.66, 1), na.rm = TRUE),
                         labels = c("Faible", "Moyen", "Élevé"),
                         include.lowest = TRUE))
```

# Carte leaflet
```{r}
library(leaflet)

# Créer une palette de couleurs pour les catégories
pal <- colorFactor(palette = "YlOrRd", domain = ve_map$categorie)

# Carte interactive
leaflet(ve_map) %>%
  addProviderTiles("CartoDB.Positron") %>%   # fond de carte clair
  addPolygons(
    fillColor = ~pal(categorie),
    weight = 1,
    opacity = 1,
    color = "white",
    dashArray = "3",
    fillOpacity = 0.8,
    highlight = highlightOptions(
      weight = 2,
      color = "#666",
      dashArray = "",
      fillOpacity = 0.9,
      bringToFront = TRUE
    ),
    label = ~paste0(DDEP_L_LIB, ": ", nb_ve, " VE"),
    labelOptions = labelOptions(
      style = list("font-weight" = "normal", padding = "3px 8px"),
      textsize = "13px",
      direction = "auto"
    )
  ) %>%
  addLegend(pal = pal, values = ~categorie, opacity = 0.7, title = "Nombre de VE",
            position = "bottomright")
```



##---------------------- 3. Autonomie et consommation moyenne d'une voiture électrique. ----------------------##


# Les données ne sont pas telechargeables, ce sont des tableaux sur une page web, je dois donc proceder à du web scraping 
```{r}
library(rvest)
library(dplyr)
library(purrr)
library(stringr)
library(janitor)

# 1. Lire la page
url <- "https://www.fiches-auto.fr/articles-auto/voiture-electrique/s-852-comparatif-des-voitures-electriques.php"
page <- read_html(url)

# 2. Sélectionner tous les H2
nodes_h2 <- page %>% html_nodes("h2")
titles <- nodes_h2 %>% html_text(trim = TRUE)

# 3. Garder uniquement les H2 contenant un prix
nodes_useful <- nodes_h2[str_detect(titles, "€|euros|[0-9]")]

# 4. Récupérer les tables associées
tables <- nodes_useful %>% map(~ {
  # chercher la première table après le H2, peu importe les nœuds intermédiaires
  next_table <- html_node(.x, xpath = "following::table[1]")
  
  # vérifier si la table existe
  if (!is.na(next_table)) {
    # convertir en data.frame et nettoyer les noms
    html_table(next_table, fill = TRUE) %>% clean_names()
  } else {
    NULL
  }
}) %>% compact()  # supprime les NULL

# 5. Vérifier le résultat
# length(tables)       # combien de tables ont été récupérées
# tables[[1]] %>% head()  # afficher les 6 premières lignes de la première table


# Nettoyer chaque table : 
# - supprimer les lignes où x1 est vide (ce sont des lignes d'en-tête répétées)
# - renommer correctement les colonnes
cleaned_tables <- tables %>% 
  map(~ .x %>% 
        filter(x1 != "") %>% 
        rename(
          modele = x1,  # Nom et version du véhicule
          acceleration = x2, # Temps 0-100 km/h
          vmax = x3, # Vitesse maximale annoncée
          coffre = x4, # Volume du coffre
          batterie = x5, # Capacité de la batterie
          autonomie = x6 # Autonomie annoncée par le constructeur
        ))

# Combiner toutes les tables en un seul data.frame
df_all <- bind_rows(cleaned_tables)

# Vérifier le résultat
df_all %>% slice(1:10)

# 3. Créer des variables numériques pour l'analyse
df_all <- df_all %>%
  mutate(
    # batterie_kwh : capacité de la batterie en kWh
    batterie_kwh = as.numeric(str_remove(batterie, "kWh")),  
    
    # autonomie_km : autonomie annoncée en kilomètres
    autonomie_km = as.numeric(str_remove(autonomie, "km")),  
)

# 4. Vérification des premières lignes
df_all %>% 
  select(modele, batterie_kwh, autonomie_km) %>% 
  slice(1:10)
```
# On travaille sur la capacité de la batterie à la place de la consommation ( car on n'a pas les données sur la consommation)


# Autonomie moyenne et capacité de batterie moyenne d'une voiture électrique
```{r}
df_all %>%
  summarise(
    autonomie_moyenne = mean(autonomie_km, na.rm = TRUE),
    batterie_moyenne = mean(batterie_kwh, na.rm = TRUE)
  )
```




# Nuage de points Batterrie vs autonomie
```{r}
ggplot(df_all, aes(x = batterie_kwh, y = autonomie_km)) +
  geom_point(color = "#2c7fb8", alpha = 0.7, size = 3) +
  labs(
    title = "Relation entre autonomie et capacité de la batterie",
    x = "Capacité de la batterie (kWh)",
    y = "Autonomie annoncée (km)"
  ) +
  theme_minimal(base_size = 14)
```


# Boxplot par catégorie de batterie
```{r}
df_all <- df_all %>%
  mutate(battery_cat = cut(batterie_kwh, breaks = c(0, 30, 60, 90, 120), 
                           labels = c("Petite", "Moyenne", "Grande", "Très grande")))

ggplot(df_all, aes(x = battery_cat, y = autonomie_km, fill = battery_cat)) +
  geom_boxplot() +
  labs(
    title = "Autonomie selon la capacité de la batterie",
    x = "Catégorie de batterie",
    y = "Autonomie (km)"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none")
```
